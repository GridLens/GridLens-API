/**
 * GridLens Smart MeterIQ â€” Core API (MSE)
 * Express server + endpoints
 */

const express = require("express");
const app = express();

app.use(express.json());

// -----------------------------
// Fake in-memory data (MVP only)
// -----------------------------
const meters = [
  {
    id: "MTR-1001",
    status: "active",
    type: "electric",
    lastReadKwh: 12450,
    lastReadAt: "2025-11-20T14:10:00Z",
    location: { city: "Holly Springs", state: "MS" }
  },
  {
    id: "MTR-1002",
    status: "active",
    type: "water",
    lastReadKwh: null,
    lastReadAt: "2025-11-21T08:22:00Z",
    location: { city: "Byhalia", state: "MS" }
  },
  {
    id: "MTR-1003",
    status: "inactive",
    type: "electric",
    lastReadKwh: 0,
    lastReadAt: "2025-11-01T02:00:00Z",
    location: { city: "Byhalia", state: "MS" }
  }
];

const amiEvents = [
  {
    id: "EVT-9001",
    meterId: "MTR-1001",
    eventType: "last_gasp",
    severity: "high",
    occurredAt: "2025-11-21T09:00:00Z"
  },
  {
    id: "EVT-9002",
    meterId: "MTR-1002",
    eventType: "comm_fail",
    severity: "medium",
    occurredAt: "2025-11-22T03:12:00Z"
  }
];

const usageReads = [
  { meterId: "MTR-1001", ts: "2025-11-22T00:00:00Z", kwh: 12.4 },
  { meterId: "MTR-1001", ts: "2025-11-22T01:00:00Z", kwh: 10.9 },
  { meterId: "MTR-1001", ts: "2025-11-22T02:00:00Z", kwh: 11.7 },
  { meterId: "MTR-1002", ts: "2025-11-22T00:00:00Z", gallons: 34 },
  { meterId: "MTR-1002", ts: "2025-11-22T01:00:00Z", gallons: 0 }
];

// ----------------------------------
// Simple â€œenginesâ€ (MVP placeholders)
// ----------------------------------
function buildBillingFlags(meter, reads) {
  const flags = [];

  // Missing reads (no usage in 24h)
  if (!reads || reads.length === 0) {
    flags.push({ code: "missing_reads", level: "high", msg: "No reads in window" });
    return flags;
  }

  // Zero-use
  const zeroCount = reads.filter(r => (r.kwh ?? r.gallons) === 0).length;
  if (zeroCount >= Math.ceil(reads.length * 0.8)) {
    flags.push({ code: "zero_use", level: "medium", msg: "Sustained zero usage" });
  }

  // Impossible spike (very naive rule for now)
  const values = reads.map(r => r.kwh ?? r.gallons);
  const max = Math.max(...values);
  const avg = values.reduce((a,b)=>a+b,0) / values.length;
  if (max > avg * 5) {
    flags.push({ code: "impossible_spike", level: "high", msg: "Usage spike exceeds threshold" });
  }

  // Inactive meter but still reading
  if (meter?.status === "inactive" && avg > 0) {
    flags.push({ code: "inactive_billing_risk", level: "high", msg: "Inactive meter producing reads" });
  }

  return flags;
}

// -------------
// Health endpoint
// -------------
app.get("/health", (req, res) => {
  res.json({ ok: true, api: "up", db: "mvp-mock" });
});

// ---------------------------
// âœ… 1) GET /meters
// List all meters
// Optional query: ?status=active&type=electric
// ---------------------------
app.get("/meters", (req, res) => {
  const { status, type } = req.query;

  let results = meters;
  if (status) results = results.filter(m => m.status === status);
  if (type) results = results.filter(m => m.type === type);

  res.json({
    count: results.length,
    data: results
  });
});

// ---------------------------
// âœ… 2) GET /meter/:id
// Get one meter by id
// ---------------------------
app.get("/meter/:id", (req, res) => {
  const { id } = req.params;
  const meter = meters.find(m => m.id === id);

  if (!meter) {
    return res.status(404).json({ error: "Meter not found", id });
  }

  res.json(meter);
});

// ---------------------------
// âœ… 3) GET /ami/events
// List AMI events
// Optional filter: ?meterId=MTR-1001&eventType=comm_fail
// ---------------------------
app.get("/ami/events", (req, res) => {
  const { meterId, eventType, severity } = req.query;

  let results = amiEvents;
  if (meterId) results = results.filter(e => e.meterId === meterId);
  if (eventType) results = results.filter(e => e.eventType === eventType);
  if (severity) results = results.filter(e => e.severity === severity);

  res.json({
    count: results.length,
    data: results
  });
});

// ---------------------------
// âœ… 4) GET /usage/:meter
// Usage reads for a given meter
// Optional query: ?limit=24
// ---------------------------
app.get("/usage/:meter", (req, res) => {
  const { meter } = req.params;
  const limit = Number(req.query.limit || 24);

  const reads = usageReads
    .filter(r => r.meterId === meter)
    .slice(-limit);

  res.json({
    meterId: meter,
    count: reads.length,
    data: reads
  });
});

// ---------------------------
// âœ… 5) GET /billing/flags
// Run Billing Integrity Engine for all meters
// Returns flags per meter
// ---------------------------
app.get("/billing/flags", (req, res) => {
  const results = meters.map(m => {
    const reads = usageReads.filter(r => r.meterId === m.id);
    const flags = buildBillingFlags(m, reads);
    return {
      meterId: m.id,
      flags,
      flagCount: flags.length
    };
  });

  res.json({
    count: results.length,
    data: results
  });
});

// -----------------------------
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`ðŸš€ API running on port ${PORT}`);
});